#### slacker
###### Less of WIMP[^1] ['slacker' interface]
---
@ Acronym of window, icon, menu, pointer (a graphical interface paradigm)
# Safety Sanity Accessibility Alertness
## Alertness:
     > an ability to switch between 'fully informative' and 'requiring attention' modes of feedback [like in an alarm setting: 'continuously shown' < == > 'toast' timelapse estimation]
     > 'traces' —signs of previous activity [moved sliders, buttons etc]
      * traces change their appearance at each consecutive invocation
      * this definition may include inobtrusive animation as well
     > 'boughs' —branch prediction of future activity ['suggestion'; movable sliders, buttons etc]
     * obtrusive and more intense than traces
     * this definition does not necessarily imply animation however
     > 'traces'&'boughs' are totally aplicable to our treefingers‑styled undo/redo or versions or a version’s undo/redo history [i.e. 'a recording of traces' & 'boughs are active for treefingers‑style history']
     > 'repeating a movement to check a distance' [ex post facto estimation; reiterant evaluation; reverberating feedback]
     * previous setting’s tracking to newly set one
     > 'vacuum diagrams'
     > two‑phase actions detection & alert ('approached element/activity <=> completed an action' [going away or staying there it turns into 'vicinity' types])
     > much of pictograms we are accustomed to are in reality absolutely meaningless —i do mismatch things like 'close a dialog' cross and 'search button' magnifier glass; ideograms are nearly irrelevant to real‑world brain —'the locus' command is that matters [even if it’s difficult to grasp with university‑type of mind or reasoning a placement is better associated with action than an icon], and to stress it once again —**color!** (a keyboard i am using right now has a bug so i cannot memorize what symbol on some three particular buttons is assigned long press [a daunting task by itself] —naturally, it takes higher loci); also not to disregard the words preferring icons
     > 'ready‑to‑be‑useful‑at‑instant' utility ever & immediately popping up just where it is used habitually can be nothing but a source of major annoyance or frustration or confusion or distraction —think of your Android’s soft‑keyboard meeting you like flattery servant every time you wanna get alone with your diary’s impressions
     > conditional menu items or conditional control elements while introducing a degree of computational complexity may greatly easen visual load ['to drink or to eat now' —it is easy to choose a branch but the alarm takes one single placeholder position in a list]; you may conceptualize it like 'ambiguous multifunctional or multimodal control elements branching user’s own workflow or decision tree'
     > b vs w elements are not distinctive one from another; switch toggle action is not memorizable; inactive elements may not be drawn the same as active ones (spatial alterations would not work, think 'a drawer‑panel' vs 'da‑vinci‑effect'); not to overload placeholders —'my only toothbrush in a cup'
     > 
     > 
# To account for memory+sensory troubles:
- 'if i do not see water then i cannot choose between two bowls using a placement of lid [green plate] (even if the target stands on a tray [which is white plate and is on pale sheet])';
- also —'pop‑soda' —'in routine feeding taking a pill from a blister is unmemorisable if there are other supplements in a batch'; [a conservative solution to it: {'pop‑a‑pill' => memory loss} BUT {'pop‑a‑pill'&'mark‑next‑one‑with‑red‑highlighter' => survival + memory loss}; issue: 'survival' but WHEN?];
- also —'blurring of blurred' —i cannot see even textured noncolored glass on a spotted or blotched surface;
- also to try avoiding plainly colored elements —they are ignored easily —to use e.g. red+green combination, it demands for user’s attention
- 
# Warped zooming [clustered fractal‑like, zonally variable zooming]
# Tools/objects in clusters
# Tools/objects placed at distinctive layers [like a drumset on a stage]
# Depth relations for tools/objects
# Sensitivity relations to triggering action for tools/objects
# Audio should be represented by higher priority graphical abstractions than anything else
- slacker is silent by default but may include 'Learning Mode' in which a voice feedback is enabled by default [definable verbosity]
# No‑ridiculous suggestions for an action (unlike widely used menus with logically inappropriate sets of actions for a given context)
# To minimize obtrusiviness of animations for the sake of easy visual location (nistagmus prevention; friendliness to 3d‑blind women) —in physical world upon encountering black object on black&white background i either try moving it either try scanning the environment (protruding black&white knife @ big glass bowl + white plate -- small black cup)
# Gesture feedback [with visually appealing primitives[^2]*]; no arrows crosses etc for a pointer; identical implementation for both touch screen and touchpad/mouse
# Never have tooltips colored the same as floating menu items!
# To try to eliminate 'the no‑two‑fingers interface' [to model associativity]
# No 'delete entry' option [to 'shade' instead]
# No‑repetitive input > also to account for child‑talk —typing 'of ps.' i make 'os p...' & typing 'given fungi' i make 'given guni' [sequencing abberation]
# System‑wide abstraction of locking input area [lock-masks for input area`s surroundings]
# Double‑zoomed as default view mode system‑wide [expandable] —zooming @cursor [active position] & @arbitary place elsewhere [fingertip position]
# RTL‑to‑LTR mapped bi‑scripting system‑wide [zoom‑following etc]
# Optionally separated zoom level values for runic and letter lines (incl. zoomed active locus) [4 independent zoom value settings]
# Switching between nibble and runic numbers input
# Zooming interface for mode-switching and editing commands [2D fractals or graphs are neat abstraction for these]
# An adjustable zooming for info‑text and input fields
# A scrolling (with optional panning)
# Overlayn tool/object mode
# Stacked [clustered] tool/object mode
# Two modes of complex input (native *a_Mode selected with overlayn tool/object mode) with 'fuse-covered-tool/object-into-overlay' option
# A versioning with an approvement prompt instead of the overwrite [implies built‑in diff (performed on history tree certainly)]; 'Approve' 'Reject' 'Diff' 'Continue' [odd grouping! no standard groupings! (i mean fixed spacing that never changes is unnatural and boring)]
# To depart from ASCII & UTF etc approach for native texts (to use a converter for existing stuff)
# Sheets & booklets for document abstraction [& ones invented for audio]
     > to evolve assembling/editing abstractions
     > to lessen/abandon notion/obtrusiviness/significance of a file/document oriented model [like that my visionary of Lavine‐Fractal FS|System]; River?
# Not to abandon 'application' paradigm
# Viewer/editor modes in apps with (various) lockings of commands/input
# Unlimited treefingers-style undo/redo (for all versions naturally) with obligatory feedback everywhere ['undo was completed: + detailed report' < XFCE‑4.18’s clearly noticeable feedback]
# To offer similar paradigm to user —to emphasize fractal or tree‑like workflow and a multitasking [incl. toolchain’s presentation: 'select' > 'choose tool' <=> 'choose tool' >  'select'; 'open version' > 'begin working with it' <=> 'begin working with a version' > 'open it’s past for a fusion'] —that implies existence of solving/decision stack checking for overlaps or inconsistencies between [possible] actions
# A browser for viewing versions before actual loading
# *viewer treefingers-styled undo/redo history
# A search for tool/object using descriptive gesture
# Bi-directional tool-to-object [clustering] bindings
# In-app editing: persistence {} with $refusal [prevents accidental alterations];
# To avoid relying on user`s readiness of getting accustomed with 'over-processed' interface --'yes! i have pushed all the buttons!'
# Odd-numbered groupings & odd grouping; if making a statusbar/taskbar do not be obsessed with fitting elements [particularly textual ones] sacrificing visibility/readability ['let that tiny font bleed over the placeholder but neatly']
# To liberate user from needing to memorize a ton of actions simply by rote
# No artificial hurdles over button action [my fingers are not respected oftenly]
# A 'no‑boring' placement[&discovery[&]] of control elements and feedback features ['a principle of greatest astonishment']
# dreamShade: a hybrid of a meter [modalDream] and a slider [easy deGauss]
# SELECTION [with features like an ability to descend into or traverse through selected minor members of chosen group]
     > to perform more than 1 actions on selected stuff

[^1]: window, icon, menu, pointer
[^2]: *a circle around finger with [context‑dependently] moving asterices —upon detecting a gesture it would be highlighted with recognized pattern (a circle, a triangle etc)
